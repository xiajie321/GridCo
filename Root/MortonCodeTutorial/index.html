<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>莫顿码 (Morton Code) - 图解教程</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <div style="margin-bottom: 10px;">
            <a href="../../index.html" class="pixel-btn" style="text-decoration: none; display: inline-block;">← 返回目录</a>
        </div>
        <header class="pixel-box header">
            <h1>莫顿码 (Morton Code)</h1>
            <p class="subtitle">又叫 Z-Order Curve：把二维坐标变成一维数字的魔法！</p>
        </header>

        <section class="pixel-box content-section" id="intro">
            <h2>0. 为什么要学莫顿码？</h2>
            <div class="dialogue-box">
                <p>想象你在整理房间，你有横着的一排抽屉（X轴）和竖着的一排柜子（Y轴）。</p>
                <p>计算机内存就像一条长长的纸带（一维的）。但是我们的地图、游戏世界通常是二维甚至三维的。</p>
                <p><strong>莫顿码</strong> 帮我们把 (X, Y) 坐标转换成一个整数，而且奇妙的是：<strong>在这个整数上相近的物体，在空间位置上也往往很近！</strong> 这对提高程序运行速度（缓存命中率）和空间查询非常有帮助。</p>
            </div>
        </section>

        <section class="pixel-box content-section" id="step1">
            <h2>1. 位交错原理 (Bit Interleaving)</h2>
            <p>莫顿码的核心思想是<strong>位交错</strong>。就像洗牌一样，把 X 和 Y 的二进制位穿插在一起。</p>
            <div class="dialogue-box">
                <p>假设我们有一个简单的 8x8 网格，坐标范围是 0 到 7。</p>
                <p>如果坐标是 X=3, Y=6：</p>
                <ul style="list-style: none;">
                    <li>X = 3 = <span class="bit-x">011</span> (二进制)</li>
                    <li>Y = 6 = <span class="bit-y">110</span> (二进制)</li>
                </ul>
                <p>我们将它们交错排列：Y₁X₁Y₂X₂Y₃X₃...</p>
                <p>莫顿码 = <span class="bit-y">1</span><span class="bit-x">0</span><span class="bit-y">1</span><span class="bit-x">1</span><span class="bit-y">0</span><span class="bit-x">1</span></p>
            </div>
            
            <p><strong>动手试试！</strong> 拖动下面的滑块，看看莫顿码是如何生成的：</p>
            
            <div class="interactive-area">
                <div class="controls">
                    <label>X: <span id="valX">0</span></label>
                    <input type="range" id="sliderX" min="0" max="7" value="0">
                </div>
                <div class="controls">
                    <label>Y: <span id="valY">0</span></label>
                    <input type="range" id="sliderY" min="0" max="7" value="0">
                </div>
                
                <div class="bit-display" id="bitDisplay">
                    <span class="bit-y">0</span><span class="bit-x">0</span><span class="bit-y">0</span><span class="bit-x">0</span><span class="bit-y">0</span><span class="bit-x">0</span>
                    <span style="color: #aaa; margin-left: 10px;"> = </span>
                    <span class="bit-val" id="mortonVal">0</span>
                </div>
                
                <p style="font-size: 0.9em; color: #666;">注意看颜色：<span style="color:var(--bit-x-color)">红色来自X</span>，<span style="color:var(--bit-y-color)">蓝色来自Y</span></p>
            </div>
        </section>

        <section class="pixel-box content-section" id="step2">
            <h2>2. 为什么叫 Z 曲线？</h2>
            <p>如果我们把所有格子按照莫顿码的大小顺序连起来，你会发现它画出了一个像字母 "Z" 的形状（其实是很多个Z嵌套在一起）。</p>
            <p>这种形状保证了它具有<strong>局部性</strong>：一维索引上相邻的数，在二维空间里通常也是挨着的。</p>
            
            <div class="interactive-area">
                <div class="controls">
                    <button id="playZBtn" class="pixel-btn">▶ 播放绘制过程</button>
                    <button id="resetZBtn" class="pixel-btn">重置</button>
                </div>
                <canvas id="zCurveCanvas" width="320" height="320"></canvas>
            </div>
        </section>

        <section class="pixel-box content-section" id="step3">
            <h2>3. 交互式网格探索</h2>
            <p>在这个 8x8 的网格上随意点击，或者移动鼠标，观察每个格子的莫顿码。</p>
            <p>特别注意：当你从一个格子移动到右边的格子时，莫顿码通常增加 1。但移动到下面时，莫顿码增加 2 (如果只看最后一位)。</p>
            
            <div class="interactive-area">
                <div id="gridContainer" class="grid-container">
                    <!-- Grid cells will be generated by JS -->
                </div>
                <div id="gridInfo" style="font-weight: bold;">
                    把鼠标放在格子上...
                </div>
            </div>
        </section>

        <section class="pixel-box content-section" id="comparison">
            <h2>4. 莫顿码 vs 普通行扫描</h2>
            <p>对比一下两种索引方式。假设我们要查找一块 2x2 的区域。</p>
            <p><strong>普通行扫描 (Row-Major)：</strong> 索引可能是 1, 2, 9, 10。跨度很大（从2跳到9）。</p>
            <p><strong>莫顿码 (Z-Order)：</strong> 索引可能是 2, 3, 4, 5（这取决于具体位置，但通常更紧凑）。</p>
            <div class="dialogue-box">
                <p>更紧凑的索引意味着计算机在读取内存时，更有可能一次性把相关数据都读进高速缓存 (Cache)，从而大大提升性能！特别是对于四叉树 (QuadTree) 这种结构，莫顿码简直是天作之合。</p>
            </div>
            
            <div class="interactive-area" style="display: flex; flex-direction: row; justify-content: space-around;">
                <div style="text-align: center;">
                    <h4>普通行扫描</h4>
                    <canvas id="rowMajorCanvas" width="200" height="200"></canvas>
                </div>
                <div style="text-align: center;">
                    <h4>莫顿码 (Z-Curve)</h4>
                    <canvas id="zOrderCompCanvas" width="200" height="200"></canvas>
                </div>
            </div>
            <div style="text-align: center; margin-top: 10px;">
                <button id="compareBtn" class="pixel-btn">运行局部性测试</button>
                <p id="compareResult"></p>
            </div>
        </section>

        <section class="pixel-box content-section" id="code-demo">
            <h2>5. C# 代码实现</h2>
            <p>虽然位交错听起来很复杂，但用位运算可以非常高效地实现！</p>
            <p>这里有一个经典的“魔术数字”方法，可以快速地把位拉开：</p>
            
            <div class="code-container">
<pre><code class="language-csharp">
public static class MortonCode
{
    // 将 16位 整数扩展为 32位，位之间插入 0
    // 例如: 1111 -> 01010101
    static uint Part1By1(uint x)
    {
        x &= 0x0000ffff;                  // x = ---- ---- ---- ---- fedc ba98 7654 3210
        x = (x ^ (x << 8)) & 0x00ff00ff;  // x = ---- ---- fedc ba98 ---- ---- 7654 3210
        x = (x ^ (x << 4)) & 0x0f0f0f0f;  // x = ---- fedc ---- ba98 ---- 7654 ---- 3210
        x = (x ^ (x << 2)) & 0x33333333;  // x = --fe --dc --ba --98 --76 --54 --32 --10
        x = (x ^ (x << 1)) & 0x55555555;  // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0
        return x;
    }

    // 编码：将 (x, y) 转换为莫顿码
    public static uint Encode(uint x, uint y)
    {
        return (Part1By1(y) << 1) + Part1By1(x);
    }

    // 解码：将莫顿码转换为 (x, y)
    // 同样使用类似的逆运算（这里省略，原理相同）
}
</code></pre>
            </div>
            <p>这种方法虽然看起来像黑魔法，但它比循环一位一位处理要快得多！</p>
        </section>

        <footer class="pixel-box footer">
            <p>恭喜！你现在掌握了空间索引的秘密武器！</p>
            <p>莫顿码广泛用于 Minecraft 这种体素游戏、GIS 地理信息系统和高性能物理引擎中。</p>
        </footer>
    </div>
    <script src="script.js"></script>
</body>
</html>
